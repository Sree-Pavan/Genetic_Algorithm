# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aBhA2Xe-y5iI1yZzaznjG3beuBdoI7oO
"""

import math
from numpy.random import randint
from numpy.random import rand
import numpy as np
import matplotlib.pyplot as plt
import random

def decode(x):
    if len(x)<5:
        for i in range(0,5-len(x)):
            x.append(0)
    elif len(x)>5:
        for i in range(0,len(x)-5):
            x.remove(i+5)
    
    if x[0] == -1:
        return float((-1*((1000*x[1])+(100*x[2])+(10*x[3])+x[4]))/10000)
    elif x[0] == 1:
        return float(((1000*x[1])+(100*x[2])+(10*x[3])+x[4])/10000)
    elif x[0] == 0:
        return 0

# def encode(i):
#     i = float(format(i,'.4f'))          
#     arr_2 = []
#     if i < 0:
#         arr_2.append(-1)
#         a = abs(i)*10000
#         b = int(a%10)
#         c = int((a-b)/10)
#         d = int(c % 10)
#         e = int((c-d)/10)
#         f = int(e % 10)
#         g = int((e-f)/10) 
#         arr_2.append(g)
#         arr_2.append(f)
#         arr_2.append(d)
#         arr_2.append(b)
#     elif i> 0 and i<1:
#         arr_2.append(1)
#         a = abs(i)*10000
#         b = int(a%10)
#         c = int((a-b)/10)
#         d = int(c % 10)
#         e = int((c-d)/10)
#         f = int(e % 10)
#         g = int((e-f)/10) 
#         arr_2.append(g)
#         arr_2.append(f)
#         arr_2.append(d)
#         arr_2.append(b)
#     elif i == 0:
#         arr_2.append([0,0,0,0])
#     elif i == 1:
#         arr_2.append([1,0,0,0])
#     return arr_2

def encode(o):
    encoded = []
   
    val = False
    if o<0:
        val = True
    if val==True:
        encoded.append(-1)
        h = abs(float(o))
        v = format(h,'.4f')
        x = [d for d in str(v)]
        for i in range(2,6):
            encoded.append(int(x[i]))
    else:
        encoded.append(1)
        h = abs(float(o))
        v = format(h,'.4f')
        x = [d for d in str(v)]
        for i in range(2,6):
            encoded.append(int(x[i]))
    return encoded
def mutation(gene_list):
    f = gene_list
    l = len(f)
    for i in range(l):
        r = True
        y = random.randrange(0,9,1)
        j = random.randrange(0,9,1)
        t = random.randrange(1,4,1)
        h = random.randrange(1,4,1)
        if r:
            f[i][0] = r
            f[i][t] = y
            f[i][h] = j
    decoded = [decode(i) for i in f]
    return decoded
def crossover(sel_pop):
    enc_pop = []
    c = []
    for i in sel_pop:
        enc_pop.append(encode(i))
    part = randint(1,4)
    l = len(enc_pop)
    if len(enc_pop)%2 == 0:
        for i in range(0,len(enc_pop),2):
            p1 = enc_pop[i]
            p2 = enc_pop[i+1]
            c1 = p1[:part] + p2[part:]
            c2 = p2[:part] + p1[part:]
            c.append(c1)
            c.append(c2)
    else:
        for i in range(0,len(enc_pop)-2,2):
            p1 = enc_pop[i]
            p2 = enc_pop[i+1]
            c1 = p1[:part] + p2[part:]
            c2 = p2[:part] + p1[part:]
            c.append(c1)
            c.append(c2)
        c.append(enc_pop[l-1])
    return c
# def selection(pop_list):
#     f = []
#     sum = 0
#     prob = []
#     sel = []
#     best = []
#     mid = []
#     poor = []
#     child = []
#     pop_length = len(pop_list)
#     for i in pop_list:
#         f.append(fitness(i))
#     for i in range(len(f)):
#         sum += f[i]
#     average = sum/pop_length
#     for i in range(len(f)):
#         sel.append(round(f[i]/average))
        
#     for i in range(pop_length):
#         if sel[i] >= 2:
#             best.append(pop_list[i])
#             prob.append(float(f[i]/sum))
#         elif sel[i] == 1:
#             mid.append(pop_list[i])
#             prob.append(float(f[i]/sum))
#         elif sel[i] == 0:
#             poor.append(pop_list[i])
    
#     selected = list(best + mid)
#     return selected
        
def selection(gene_list):
    if len(gene_list) == 1:
        return gene_list
    else:
        l = len(gene_list)
        aver = []
        total = 0
        selected = []
        scores = [np.round(fitness(i),4) for i in gene_list]
        for i in scores:
            total += i
        for i in range(l):
            aver.append(gene_list[i]//total)
        for i in range(len(aver)):
            if abs(aver[i])>=1:
                selected.append(gene_list[i])
    return selected
    
    
    
    
    
    
    
    
    
def fitness(t):
    return float(math.sin(float(10*math.pi*t)) + 1)
        

def population_check(pop):
    for i in pop:
        if i == None:
            pop.remove(i)
    for i in pop:
        if i < -0.5 or i > 1:
            pop.remove(i)
    return pop

iterations = 100
ini_pop = []
ran_pop =[]
for i in np.arange(-0.5,1,0.0001):
    ini_pop.append(i)
ini_pop.append(1)
ini_len = int(len(ini_pop))
k = int(ini_len/5)
ran_pop = random.sample(ini_pop,k)

def genetic_algorithm(genes):
    selected = selection(genes)
    crossed = crossover(selected)
    mutated = mutation(crossed)
    pop_check = population_check(mutated)
    return pop_check

x = []
max_scores = []
min_scores = []
aver_scores = []
best_individuals = []
for i in range(iterations):
    final_list = genetic_algorithm(ran_pop)
    for j in range(len(final_list)):
        x.append(fitness(final_list[j]))
    max_scores.append(max(x))
    t = x.index(max(x))
    best_individuals.append(final_list[t])

    min_scores.append(min(x))
    aver_scores.append(np.average(x))
    ran_pop += final_list[:]
    

all_iter= []
for i in range(iterations):
    all_iter.append(i)
fig, axs= plt.subplots()
axs.plot(all_iter,max_scores)
axs.set_title("Best only mutation")
axs.plot(all_iter,min_scores)
axs.set_title("worst only mutation")
axs.plot(all_iter,aver_scores)
axs.set_title("average mutation")
axs.plot(all_iter,best_individuals)
axs.set_title("average mutation")